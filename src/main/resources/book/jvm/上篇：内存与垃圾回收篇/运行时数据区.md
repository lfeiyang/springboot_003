# <font face=幼圆 color=white>运行时数据区</font>

- <font face=STCAIYUN color=red>一个Java程序对应一个进程</font>
- <font face=STCAIYUN color=red>一个进程对应一个JVM实例</font>
- <font face=STCAIYUN color=red>一个JVM实例中只有一个运行时数据区</font>
- <font face=STCAIYUN color=red>一个进程中的多个线程需要共享一个方法区、堆空间</font>
- <font face=STCAIYUN color=red>每一个进程拥有独立的一套程序计数器、本地方法栈、虚拟机栈</font>

![运行时数据区](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\运行时数据区.png)



1. <font face=幼圆 color=white>每个线程：独立包括程序计数器、栈、本地栈</font>
2. <font face=幼圆 color=white>线程共享：堆、堆外内存（永久代或元空间、代码缓存）</font>

![栈、堆、方法区的交互关系](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\栈、堆、方法区的交互关系.png)

## <font face=幼圆 color=white>一、程序计数器（PC寄存器）</font>

​		<font face=幼圆 color=white>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行器引擎读取下一条指令。</font>

![PC寄存器](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\PC寄存器.png)

### <font face=幼圆 color=white>1.1、线程私有</font>

​		<font face=幼圆 color=white>为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是未每一个线程都分配一个PC寄存器</font>

![线程私有](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\线程私有.png)



## <font face=幼圆 color=white>二、虚拟机栈</font>

### <font face=幼圆 color=white>2.1、Java虚拟机栈是什么</font>

​		<font face=幼圆 color=white>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个虚拟机的栈帧（Stack Frame）,对应着一次次的Java方法调用</font>

1. <font face=幼圆 color=red>线程私有的</font>

![虚拟机栈](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\虚拟机栈.png)

### <font face=幼圆 color=white>2.2、生命周期</font>

​		<font face=幼圆 color=white>生命周期和线程一致</font>

### <font face=幼圆 color=white>2.3、作用</font>

​		<font face=幼圆 color=white>主管Java程序的运行，它保存方法的局部变量(八种基本数据类型、对象的引用)、部分结果，并参与方法的调用和返回</font>

### <font face=幼圆 color=white>2.4、栈的优点</font>

1. <font face=幼圆 color=white>栈是一种快速有效的存储方式，速度仅次于PC计数器</font>

2. <font face=幼圆 color=white>JVM直接对Java栈的操作只有两个：</font>

   ```text
   1.每个方法执行，伴随着进栈（入栈、压栈）
   2.执行方法结束后的出栈工作
   ```

3. <font face=幼圆 color=white>对于栈来说不存在垃圾回收问题</font>

### <font face=幼圆 color=white>2.5、栈的异常</font>

#### <font face=幼圆 color=white>2.5.1、栈的内存溢出异常</font>

<font face=幼圆 color=white>Java虚拟机允许<font face=幼圆 color=red>Java栈的大小是动态的或固定不变的</font></font>

1. <font face=幼圆 color=white>如果采用固定大小的Java虚拟机栈，那每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机会抛出一个<font face=幼圆 color=red>栈溢出StackOverflowError</font>异常。</font>
2. <font face=幼圆 color=white>如果Java虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<font face=幼圆 color=red>内存溢出OutOfMemoryError</font>异常。</font>

#### <font face=幼圆 color=white>2.5.2、栈的内存固定大小 [ -Xss](https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE)</font>

### <font face=幼圆 color=white>2.6、栈的存储结构和运行原理</font>

1. <font face=幼圆 color=white>栈的数据都已栈帧（Stack Frame）的格式存在</font>
2. <font face=幼圆 color=white>先进后出原理</font>
2. <font face=幼圆 color=white>方法的结束分为两种：正常结束 return 和出现未捕获的异常抛出异常的方式结束</font>

![栈的运行原理](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\栈的运行原理.png)

#### <font face=幼圆 color=white>2.6.1、栈帧的内部机构</font>

1. <font face=幼圆 color=red>局部变量表（Local Variables）</font>
1. <font face=幼圆 color=red>操作数栈（Operand Stack）</font>
1. <font face=幼圆 color=white>动态连接（Dynamic Linking）,运行时常量池的方法引用</font>
1. <font face=幼圆 color=white>方法返回地址（Return Address）,方法正常退出或异常退出的定义</font>
1. <font face=幼圆 color=white>一些附加信息</font>

![栈帧的内部结构](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\栈的内部结构.png)

##### <font face=幼圆 color=white>2.6.1.1、局部变量表</font>

1. <font face=幼圆 color=white><font face=幼圆 color=red>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</font>，这些数据类型包括各类基本数据类型、对象引用（reference）,以及returnAddress类型</font>
2. <font face=幼圆 color=white>由于局部变量是建立在线程的栈上，是线程的私有数据，因此<font face=幼圆 color=red>不存在数据安全问题</font></font>
3. <font face=幼圆 color=white><font face=幼圆 color=red>局部变量表所需的容量大小是在编译期确定下来的</font>，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量的大小的</font>

###### <font face=幼圆 color=white>2.6.1.1.1、字节码中方法内部结构剖析</font>

 

###### <font face=幼圆 color=white>2.6.1.1.2、Slot的理解</font>

1. <font face=幼圆 color=white>参数值的存放总是在局部变量数组index0开始，到数组长度-1的索引结束</font>

2. <font face=幼圆 color=white>局部变量表，<font face=幼圆 color=red>最基本的存储单元是Slot（变量槽）</font></font>

3. <font face=幼圆 color=white>局部变量变中存放编译器可知的各种基本数据类型（8种），引用类型（reference）,returnAddress类型的变量</font>

4. <font face=幼圆 color=white>在局部变量表里，<font face=幼圆 color=red>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</font></font>

   <font face=幼圆 color=white>（1）byte、short、char存储前被转换为int，boolean也被转换为int，0表示false,非0表示true</font>

   <font face=幼圆 color=white>（2）long和double则占用两个slot</font>

5. <font face=幼圆 color=white>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表种指定的局部变量值</font>

6. <font face=幼圆 color=white>当一个实例方法被调用的时候，他的方法参数和方法体内部定义的局部变量将会<font face=幼圆 color=red>按照顺序被复制到局部变量表中的每一个Slot上</font></font>

7. <font face=幼圆 color=white><font face=幼圆 color=red>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可</font>（比如：访问long或double类型变量）</font>

8. <font face=幼圆 color=white>如果当前帧是由构造方法或者实例方法创建的，那么<font face=幼圆 color=red>该对象引用this将会存放在index为0的slot处</font>，其余的参数按照表顺序继续排列</font>

   

![Slot槽](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\Slot槽.png)



###### <font face=幼圆 color=white>2.6.1.1.3、静态变量和局部变量的对比及小结</font>

1. <font face=幼圆 color=white>变量的分类：</font>

   <font face=幼圆 color=white>按照数据类型分：① 基本数据类型  ② 引用数据类型</font>

   <font face=幼圆 color=white>按照在类中申明的位置分：① 成员变量：在使用前，都经历过默认初始化值</font>

   ​													<font face=幼圆 color=white>（1）<font face=幼圆 color=red>类变量</font>：static修饰，Linking的prepare阶段：给类变量默认初始值 --> iniizatial阶段给代码块赋值。</font>

   ​												    <font face=幼圆 color=white>（2）<font face=幼圆 color=red>实例变量</font>：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。</font>

   ​											<font face=幼圆 color=white>② 局部变量：<font face=幼圆 color=red>在使用前必须进行显示赋值！</font>否则，编译不通过</font>



##### <font face=幼圆 color=white>2.6.1.2、操作数栈 Operand Stack</font>

1. <font face=幼圆 color=white>每一个独立的栈帧中除了包含局部变量表以外，还包含一个<font face=幼圆 color=red>后进先出</font>（Last-First-Out）的操作数栈，也可以称之为<font face=幼圆 color=red>表达式栈</font>（Expression Stack）。</font>
2. <font face=幼圆 color=red>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。</font>
   - [x] <font face=幼圆 color=white>某些操作数指令将值压入操作数栈，其余字节码指令将操作数取出栈。使用它们后再把结果压入栈。</font>
   - [x] <font face=幼圆 color=white>比如：执行复制、交换、求和等操作</font>
3. <font face=幼圆 color=white><font face=幼圆 color=red>如果被调用的方法带有返回值的话，其返回值会压入当前栈帧的操作数栈中</font>，并更新PC寄存器中下一条需要执行的字节码指令</font>
3. 栈顶缓存技术TOP-Of-Stack

![操作数栈](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\操作数栈.png)



##### <font face=幼圆 color=white>2.6.1.3、动态链接</font>

1. <font face=幼圆 color=white>动态链接也可称为**指向运行时常量池的方法引用**</font>
2. <font face=幼圆 color=white>每一个栈帧内部都包含一个指向运行时常量池中该线程所属方法的引用。</font>
3. <font face=幼圆 color=white>应用的目的就是为了支持当前方法的代码能实现动态链接。</font>
4. <font face=幼圆 color=white>在java源文件被编译到字节码文件时，**所有的变量和方法引用都作为符号引用保存在class文件的常量池里**。</font>
5. <font face=幼圆 color=white>描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么，**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**。</font>

![动态链接](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\动态链接.png)



###### <font face=幼圆 color=white>2.6.1.3.1、两种链接方式</font>

1. #### <font face=幼圆 color=white>静态链接：当一个字节码文件被装载进[jvm](https://so.csdn.net/so/search?q=jvm&spm=1001.2101.3001.7020)内部时，如果被**调用的目标方法在编译期可知，且运行期保持不变**。为静态链接。</font>

2. #### <font face=幼圆 color=white>动态链接：如果被调用的方法在**编译期无法被确定下来**，也就是说，只能够在程序运行期间调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</font>



###### <font face=幼圆 color=white>2.6.1.3.2、对应的方法的绑定机制</font>

1. #### <font face=幼圆 color=white>早期绑定：指被调用的目标方法如果在**编译期可知，且运行期保持不变时**，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号转换为直接引用。</font>

2. #### <font face=幼圆 color=white>晚期绑定：如果**被调用的方法在编译期无法确定下来**，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称为晚期绑定。</font>



###### <font face=幼圆 color=white>2.6.1.3.3、虚方法与非虚方法</font>

1. #### <font face=幼圆 color=white>非虚方法：</font>

   - <font face=幼圆 color=white>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。</font>
   - <font face=幼圆 color=white>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</font>

2. #### <font face=幼圆 color=white>虚方法：</font>

	- <font face=幼圆 color=white>在编译期间无法确定的方法。</font>



###### <font face=幼圆 color=white>2.6.1.3.4、[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)中提供的几条方法调用指令</font>

 <font face=幼圆 color=white>A.普通调用指令</font>

- #### <font face=幼圆 color=white>invokestatic:调用静态方法，解析阶段确定唯一方法版本</font>

- #### <font face=幼圆 color=white>invokespecial:调用< init >方法，私有哦父类方法，解析阶段确定唯一方法版本。</font>

- #### <font face=幼圆 color=white>invokevirtual:调用所有虚方法</font>

- #### <font face=幼圆 color=white>invokeinterface:调用接口方法</font>

 <font face=幼圆 color=white>B.动态调用指令：</font>

- #### <font face=幼圆 color=white>invokedynamic:动态解析出需要调用的方法，然后执行。</font>

<font face=幼圆 color=yellow>**注**：前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic执行则支持用户确定方法版本。其中，**invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰方法外)称为虚方法**。</font>



###### <font face=幼圆 color=white>2.6.1.3.5、方法重写的本质与虚拟方法表</font>

1. <font face=幼圆 color=white>java语言中重写的本质</font>

   - <font face=幼圆 color=white>a 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</font>

   - <font face=幼圆 color=white>b 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。</font>

   - <font face=幼圆 color=white>c 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</font>

   - <font face=幼圆 color=white>d 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodsrror 异常。</font>

2. <font face=幼圆 color=white> IllegalAccessError介绍</font>

​		<font face=幼圆 color=white>程序试图访问或修改一个属性或调用一个方法。这个属性或方法，如果没有权限访问，一般的，会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</font>


3. <font face=幼圆 color=white>方法的调用：虚方法表</font>

   - <font face=幼圆 color=white>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表</font>

   - <font face=幼圆 color=white>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</font>

   - <font face=幼圆 color=white>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</font>

   - <font face=幼圆 color=white>虚方法表是什么时候被创建的呢？</font>

   - <font face=幼圆 color=red>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</font>

![虚拟方法表](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\虚拟方法表.png)



##### <font face=幼圆 color=white>2.6.1.4、方法返回地址（return address）</font>

1. <font face=幼圆 color=white>存放调用该方法的 pc [寄存器](https://so.csdn.net/so/search?q=寄存器&spm=1001.2101.3001.7020)的值</font>
2. <font face=幼圆 color=white>一个方法的结束，有两种方式</font>

   - <font face=幼圆 color=white>正常执行完成。</font>

   - <font face=幼圆 color=white>出现未处理的异常，非正常退出。</font>

3. <font face=幼圆 color=white>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<font face=幼圆 color=red>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</font>而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</font>



##### <font face=幼圆 color=white>2.6.1.5、栈帧中的一些附加信息</font>



##  <font face=幼圆 color=white>三、本地方法栈</font>

###  <font face=幼圆 color=white>3.1、本地方法栈的特点</font>

1. <font face=幼圆 color=white>Java虚拟机栈于管理Java方法的调用，而**本地方法栈用于管理本地方法的调用**。</font>

2. <font face=幼圆 color=white>本地方法栈，也是线程私有的。</font>

3. <font face=幼圆 color=white>允许被实现成**固定或者是可动态扩展的内存大小**（在内存溢出方面和虚拟机栈相同）</font>
   - <font face=幼圆 color=white>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常</font>
   - <font face=幼圆 color=white>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</font>
   
4. <font face=幼圆 color=white>本地方法一般是使用C语言实现的。</font>


5. <font face=幼圆 color=white>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</font>

![本地方法栈](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\本地方法栈.png)

###  <font face=幼圆 color=white>3.1、注意事项</font>

1. <font face=幼圆 color=white>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</font>

   - <font face=幼圆 color=white>本地方法可以通过本地方法接口来**访问虚拟机内部的运行时数据区**</font>
   - <font face=幼圆 color=white>它甚至可以直接使用本地处理器中的寄存器</font>
   - <font face=幼圆 color=white>直接从本地内存的堆中分配任意数量的内存</font>

3. <font face=幼圆 color=white>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</font>
4. <font face=幼圆 color=white>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</font>



##  <font face=幼圆 color=white>四、堆</font>

###  <font face=幼圆 color=white>4.1、堆的核心概念</font>

1. <font face=幼圆 color=white>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</font>
2. <font face=幼圆 color=white>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间</font>
   - <font face=幼圆 color=white>堆内存的大小是可以调节的</font>


3. <font face=幼圆 color=white>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</font>
4. <font face=幼圆 color=white>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</font>
- <font face=幼圆 color=white>-Xms10m：最小堆内存</font>
  
- <font face=幼圆 color=white>-Xmx10m：最大堆内存</font>


5. <font face=幼圆 color=white>《Java虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</font>
   - <font face=幼圆 color=white>“几乎”所有的对象实例都在这里分配内存。它是从实际使用角度看的， 因为还有一些对象是在栈上分配的</font>


6. <font face=幼圆 color=white>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</font>

7. <font face=幼圆 color=white>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</font>

   - <font face=幼圆 color=white>也就是触发了GC的时候，才会进行回收。</font>

   - <font face=幼圆 color=white>如果堆中对象马上被回收，那么用户线程就会受到影响，因为有 stop the word。</font>

8. <font face=幼圆 color=white>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域</font>

9. <font face=幼圆 color=white>现代垃圾收集器大部分基于分代收集理论设计，堆空间细分为：</font>

  - [x] <font face=幼圆 color=white>Java 7及之前堆内存逻辑上分为：新生区+养老区+永久区</font>

| 分区                           | 简称       |
| ------------------------------ | ---------- |
| Young Generation Space新生区   | Young/New  |
| Tenure generation space 养老区 | old/Tenure |
| Permanent Space    永久区`     | Perm       |

  


  - [x] <font face=幼圆 color=white>Java 8及之后堆内存逻辑分为：新生区+养老区+元空间</font>

| 分区                                                   | 简称       |
| ------------------------------------------------------ | ---------- |
| Young Generation Space新生区，细分为Eden区和Survivor区 | Young/New  |
| Tenure generation space 养老区                         | old/Tenure |
| Permanent Space    元空间                              | Perm       |

<font face=幼圆 color=white>其中，新生区=新生代=年轻代；养老区=老年区=老年代；永久区=永久代</font>

###  <font face=幼圆 color=white>4.2、[堆空间大小设置](https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE)</font>

- <font face=幼圆 color=white>jps 查看线程</font>
- <font face=幼圆 color=white>jps-gc pid 查看指定线程详细</font>
- <font face=幼圆 color=white>jinfo -flag SurvivorRatio pid</font>

1. <font face=幼圆 color=white>设置堆空间大小的参数①-Xms 用来设置堆空间（年轻代+老年代）的初始空间大小 </font>
   - <font face=幼圆 color=white>-X是JVM的运行参数</font>
   - <font face=幼圆 color=white>ms是memory start</font>
   - <font face=幼圆 color=white>-Xmx 用来设置堆空间（）的最大内存大小</font>

2. <font face=幼圆 color=white>默认堆空间大小</font>
   - <font face=幼圆 color=white>初始内存大小：物理电脑内存大小  / 64</font>
   - <font face=幼圆 color=white>最大内存大小：物理电脑内存大小 / 4</font>

3. <font face=幼圆 color=white>手动设置堆内存大小</font>

- <font face=幼圆 color=white>开发中建议将初始堆内存和最大堆内存设置成相同的值</font>
- <font face=幼圆 color=white>-Xms600m -Xmx600m</font>
- <font face=幼圆 color=white>-Xms600m -Xmx600m -XX:+PrintGCDetails 幸存者区只会用一个</font>

#### <font face=幼圆 color=white>4.2.1、OOM举例</font>

​		<font face=幼圆 color=red>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</font>



### <font face=幼圆 color=white>4.3、年轻代和老年代</font>

1. <font face=幼圆 color=white>存储在JVM中的Java对象可以被划分为两类：</font>
2. <font face=幼圆 color=white>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</font>
3. <font face=幼圆 color=white>其中年轻代又可以划分为Eden空间、Survivor0 空间和 Survivor1 空间（有时也叫做from区、to区）</font>
4. <font face=幼圆 color=white>配置新生代与老年代在堆结构的占比</font>

   - <font face=幼圆 color=white>默认 -XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</font>
   - <font face=幼圆 color=white>可以修改 -XX：NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</font>
   - <font face=幼圆 color=white>jinfo -flag SurvivorRatio PID</font>
   - <font face=幼圆 color=white>jinfo -flag NewRatio PID</font>

5. <font face=幼圆 color=white>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是 8：1：1</font>
   - <font face=幼圆 color=white>当然开发人员可以通过选项"-XX：SurvivorRatio"调整这个空间比例。比如：-XX：SurvivorRatio=8</font>
   - <font face=幼圆 color=white>几乎所有的Java对象都是在Eden区被new出来的。</font>
   - <font face=幼圆 color=white>绝大部分的Java对象的销毁都在新生代进行了。</font>
   - <font face=幼圆 color=white>IBM公司的专门研究表明，新生代中80%的对象都是"朝生夕死"的。</font>
   - <font face=幼圆 color=white>-XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配粗略</font>

6. <font face=幼圆 color=white>可以使用选项"-Xmn"设置新生代最大内存大小（一般不会使用这个配置）</font>，<font face=幼圆 color=red>优先级高</font>

![堆](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\堆.png)

![堆比例](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\堆比例.png)



### <font face=幼圆 color=white>4.4、对象分配过程</font>

#### <font face=幼圆 color=white>4.4.1、一般过程</font>

![第一次GC](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\第一次GC.png)

1. <font face=幼圆 color=white>new的对象先放着伊甸园区；</font>
2. <font face=幼圆 color=white>当伊甸园区空间满了时，程序又要创建新的对象时，JVM垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区的不再被其他对象所引用的对象进行销毁，再加载新的对象到伊甸园区；</font>
3. <font face=幼圆 color=white>然后将伊甸园区剩余的对象移动到幸存者0区，每个对象被分配了一个年龄计数器（age），每进行一次GC，幸存下来的对象age累加，上面的两个幸存对象age被赋值为1；</font>
4. <font face=幼圆 color=white>GC完成后，此时伊甸园区是空的了。</font>



![第二次GC](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\第二次GC.png)

1. <font face=幼圆 color=white>当伊甸园区空间又满了时，进行第二次GC，将伊甸园区幸存的对象放入S1区，age此时为1；</font>
2. <font face=幼圆 color=white>同时对S0区的对象进行判断是否还被使用，如果被使用的话，就将其放入S1区，age累加此时为2；</font>
3. <font face=幼圆 color=white>第二次GC完成后，S0区为空了，此时S0区为To区，S1区为From区；</font>



![第n次GC](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\第n次GC.png)

1. <font face=幼圆 color=white>第N次GC时，我们发现S1区的有两个对象的age已经是15了，如果此时这两个对象还是被引用的，则将其晋升到Old区；</font>
2. <font face=幼圆 color=white>其中15为默认阈值，这个阈值是可以自己设置：`-XX:MaxTenuringThreshold=<N>`</font>



#### <font face=幼圆 color=white>4.4.2、特殊过程</font>

![特殊GC](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\特殊GC.png)

1. <font face=幼圆 color=white>创建一个新的对象时，首先判断Eden区是否放的下，如果放的下，就为其分配内存，放不下的话，就进行YGC；</font>
2. <font face=幼圆 color=white>然后再判断Eden区是否放的下，如果此时放的下的话，就为其分配内存，如果还是放不下，说明这个对象比伊甸园区的空间还要大，这个对象是个超大对象，此时将其放入Old区，如果Old区也放不下，就进行FGC，然后再判断Old区能不能放下，放的下就存在Old区，如果还是放不下，就会出现OOM异常；</font>
3. <font face=幼圆 color=white>在进行YGC的时候，幸存的对象会放入幸存区，此时判断是否能放下，如果幸存区放不下，就会直接放入Old区。</font>

#### <font face=幼圆 color=white>4.4.3、Minor GC、Major GC、Full GC的区别</font>

##### <font face=幼圆 color=white>4.4.3.1、概述</font>

​		<font face=幼圆 color=white>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC）,一种是整堆收集（Full GC)</font>

1. <font face=幼圆 color=white>部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:</font>

   - <font face=幼圆 color=white>新生代收集（Minor GC / Young Gc）:只是新生代的垃圾收集</font>

   - <font face=幼圆 color=white>老年代收集（Major Gc / old GC):只是老年代的垃圾收集。目前,只有CMS GC会有单独收集老年代的行为。注意，很多时候Major Gc会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font>

   - <font face=幼圆 color=white>混合收集（Mixed Gc):收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 Gc会有这种行为</font>

2. <font face=幼圆 color=white>整堆收集（Ful1 GC):收集整个java堆和方法区的垃圾收集。</font>

##### <font face=幼圆 color=white>4.4.3.1、触发条件</font>

1. <font face=幼圆 color=white>年轻代GC(Minor GC)触发机制:</font>

   - <font face=幼圆 color=white>当年轻代空间不足时，就会触发Minor Gc，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。(每次 Minor GC会清理年轻代的内存。)</font>

   - <font face=幼圆 color=white>因为Java对象大多都具备朝生夕灭的特性，所以 Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</font>

   - <font face=幼圆 color=white>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</font>

2. <font face=幼圆 color=white>老年代GC (Major GC/Full GC)触发机制:</font>

   - <font face=幼圆 color=white>指发生在老年代的Gc，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</font>

   - <font face=幼圆 color=white>出现了Major GC，经常会伴随至少一次的Minor Gc（但非绝对的，在Parallelscavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。也就是在老年代空间不足时，会先尝试触发Minor Gc。如果之后空间还不足，则触发Major GC</font>

   - <font face=幼圆 color=white>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</font>

   - <font face=幼圆 color=white>如果Major GC后，内存还不足，就报OOM了。</font>

3. <font face=幼圆 color=white>Fu11 GC触发机制:（后面细讲）触发Full GC执行的情况有如下五种:</font>

   - <font face=幼圆 color=white>调用system.gc()时，系统建议执行Full Gc，但是不必然执行</font>

   - <font face=幼圆 color=white>老年代空间不足</font>

   - <font face=幼圆 color=white>方法区空间不足</font>

   - <font face=幼圆 color=white>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</font>

   - <font face=幼圆 color=white>由Eden区、 survivor spacee (From Space)区向survivor space1 (Tospace)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</font>

<font face=幼圆 color=yellow>**说明: full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。**</font>

#### <font face=幼圆 color=white>4.4.4、堆空间的分代思想</font>

<font face=幼圆 color=red>优化 GC 性能</font>

#### <font face=幼圆 color=white>4.4.5、内存分配策略</font>

![一般策略](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\一般策略.png)

1. <font face=幼圆 color=white>对象会被优先分配到`Eden`区</font>
2. <font face=幼圆 color=white>大对象，如果`Eden`区放不下，就会被直接放到老年代</font>
3. <font face=幼圆 color=white>长期存活的对象(`Survivor`区中的对象的`age`超过[阈值](https://so.csdn.net/so/search?q=阈值&spm=1001.2101.3001.7020)的对象)，会被放到老年代</font>
4. <font face=幼圆 color=white>动态年龄判断。如果`Survivor`区中的相同年龄的所有对象大小的总和大于`Survivor`空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到`MaxTenuringThreshold`中要求的年龄。比如说年龄为`5`的所有的对象的大小总和超过了`Survivor`空间的一半，那么这些对象就会被直接放到老年代。</font>

#### <font face=幼圆 color=white>4.4.6、对象分配过程：TLAB</font>

##### <font face=幼圆 color=white>4.4.6.1、为什么会有 TLAB</font>

1. <font face=幼圆 color=white>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据；</font>
2.  <font face=幼圆 color=white>由于对象实例的创建在[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)中十分频繁，一次在并发环境下从堆区中划分内存空间是线程不安全的；</font>
3. <font face=幼圆 color=white>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</font>

##### <font face=幼圆 color=white>4.4.6.2、什么是TLAB？</font>

1. <font face=幼圆 color=white>从[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden区域内。</font>
2. <font face=幼圆 color=white>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略</font>

##### <font face=幼圆 color=white>4.4.6.3、TLAB的再说明</font>

1. <font face=幼圆 color=white>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</font>
2. <font face=幼圆 color=white>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。</font>
3. <font face=幼圆 color=white>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</font>
4. <font face=幼圆 color=white> 一旦对象在LAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</font>

![TLAB](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\TALB.png)

### <font face=幼圆 color=white>4.5、堆空间参数设置</font>

- <font face=幼圆 color=white>-XX:+PrintFlagsInitial：查看所有的参数的默认初始值</font>
- <font face=幼圆 color=white>-XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</font>
- <font face=幼圆 color=white>-Xms：初始堆空间[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)（默认为物理内存的1/64）</font>
- <font face=幼圆 color=white>-Xmx：[最大堆](https://so.csdn.net/so/search?q=最大堆&spm=1001.2101.3001.7020)空间内存（默认为物理内存的1/4）</font>
- <font face=幼圆 color=white>-Xmn：设置新生代的大小。（初始值及最大值）</font>
- <font face=幼圆 color=white>-XX:NewRatio：配置新生代与老年代在堆结构的占比</font>
- <font face=幼圆 color=white>-XX:SurvivorRatio：设置新生代中 Eden 和 S0/S1 空间的比例</font>
- <font face=幼圆 color=white>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</font>
- <font face=幼圆 color=white>-XX:+PrintGCDetails：输出详细的GC处理日志</font>
- <font face=幼圆 color=white>-XX:+PrintGC（-verbose:gc）：打印gc简要信息，两个参数输入效果一样</font>
- <font face=幼圆 color=white>-XX:HandlePromotionFalilure：是否设置空间分配担保</font>

  1. <font face=幼圆 color=white>在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</font>

  2. <font face=幼圆 color=white>如果大于，则此次 Minor GC是安全的</font>

  3. <font face=幼圆 color=white>如果小于，则虚拟机会查看-XX:HandlePromotionFailure 设置值是否允担保失败</font>

  4. <font face=幼圆 color=white> 如果 HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</font>

  5.   <font face=幼圆 color=white>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的</font>

  6.   <font face=幼圆 color=white>如果小于，则改为进行一次 FullGC</font>

  7. <font face=幼圆 color=white>如果 HandlePromotionFailure=false，则改为进行一次 Full Gc</font>

  8. <font face=幼圆 color=white>在 JDK6 Update24（JDK7） 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 openJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它</font>

  9. <font face=幼圆 color=white>JDK6 Update 24（JDK7）之后的规则变为：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行FullGC</font>

### <font face=幼圆 color=white>4.6、通过逃逸分析看堆空间的对象分配策略</font>

#### <font face=幼圆 color=white>4.6.1、堆是分配对象的唯一选择么？</font>

<font face=幼圆 color=white>在《深入理解Java虚拟机》中关于 Java 堆内存有这样一段描述：</font>

- <font face=幼圆 color=white>随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了</font>

#### <font face=幼圆 color=white>4.6.2、逃逸分析</font>

- <font face=幼圆 color=white>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术</font>

#### <font face=幼圆 color=white>4.6.3、定制的 TaoBao VM</font>

- <font face=幼圆 color=white>此外，前面提到的基于 OpenJDK 深度定制的 TaoBao VM ，其中**创新的 GCIH（GC Invisible Heap）技术实现Off-Heap**，将生命周期较长的 Java 对象从 Heap 中移至 Heap 外，并且 GC 不能管理 GCIH内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的</font>

#### <font face=幼圆 color=white>4.6.4、逃逸分析原理</font>

1. <font face=幼圆 color=white>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</font>
2. <font face=幼圆 color=white>通过逃逸分析， Java HotSpot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</font>
3. <font face=幼圆 color=white>逃逸分析的基本行为就是分析对象动态作用域：</font>

   - <font face=幼圆 color=white>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</font>

   - <font face=幼圆 color=white>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中</font>

<font face=幼圆 color=red>开发中能使用局部变量的，就不要使用在方法外定义</font>

### <font face=幼圆 color=white>4.7、逃逸分析：代码优化</font>

#### <font face=幼圆 color=white>4.7.1、逃逸分析：栈上分配</font>

​		<font face=幼圆 color=white>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了</font>

1. <font face=幼圆 color=white>设置 JVM 参数，表示未开启逃逸分析：-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</font>
2. <font face=幼圆 color=white>设置 JVM 参数，开启逃逸分析：-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</font>

#### <font face=幼圆 color=white>4.7.2、逃逸分析：同步省略</font>

 - <font face=幼圆 color=white>简单来说就是在使用synchronized锁的时候，如果其所在的同步代码块的对象只会被一个线程访问，而不会被另外一个线程访问，即只有一个线程会访问这个对象，那么JIT编译器会在编译期间就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫**同步省略**，也叫 **锁消除**。</font>

```java
/**
 * 同步省略说明:
 * 同步代码需要加锁的目的是保证多个线程操作一个资源的时候保证安全性
 * 但是下面的同步代码块每次的锁对象hollos都是新new出来的，这意味着每次锁的是一个新的对象，如果存在多线程，操作的不会是一个对象
 * 因此这段代码是错误展示，但能说明同步省略的问题。
 */
public class SynchronizedTest {
    public void f() {
        Object hollis = new Object();
        synchronized(hollis) {
            System.out.println(hollis);
        }
    }
    
    //代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中
    //并不会被其他线程所访问控制，所以在JIT编译阶段就会被优化掉。
    //优化为 ↓
    public void f2() {
        Object hollis = new Object();
        System.out.println(hollis);
    }
}
```



#### <font face=幼圆 color=white>4.7.3、分离对象和标量替换</font>

1. <font face=幼圆 color=white>有的对象可能不需要作为一个连续的内存结构也可以被访问到，那么对象的部分(或全部)可以不储存到内存，而是储存到CPU寄存器中</font>
2. <font face=幼圆 color=white>**标量**:是指一个无法在分解成更小的数据的数据。Java中的原始数据类型就是标量</font>
3. <font face=幼圆 color=white>**聚合量**：相对的，哪些可以继续分解的数据叫聚合量，如java中的对象就是聚合量，可以分解为更小的聚合量和标量</font>
4. <font face=幼圆 color=white>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其成员变量来替代。这个过程就是标量替换</font>

```java
public class ScalarTest {
    public static void main(String[] args) {
        alloc();   
    }
    public static void alloc(){
    //为标量替换之前
        Point point = new Point(1,2);
    }
}
class Point{
    private int x;
    private int y;
    public Point(int x,int y){
        this.x = x;
        this.y = y;
    }
}
```

```java
public static void alloc(){
    int x = 1;
    int y = 2;
}
```

​		<font face=幼圆 color=white>不难看出，Point类对象在本方法内调用，没有发生逃逸，可以继续通过标量替换替换成更小的标量，这就省去了在堆上创建对象的过程，节省了内存空间，标量替换为栈上分配提供了很好的基础</font>

### <font face=幼圆 color=white>4.8、逃逸分析小结</font>

1. <font face=幼圆 color=white>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的</font>
2. <font face=幼圆 color=white>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</font>
3. <font face=幼圆 color=white>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了</font>
4. <font face=幼圆 color=white>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段</font>

### <font face=幼圆 color=white>4.9、堆小结</font>

1. <font face=幼圆 color=white>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命</font>
2. <font face=幼圆 color=white>老年代放置长生命周期的对象，通常都是从 Survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代</font>
3. <font face=幼圆 color=white>当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC 。当 GC 发生在老年代时则被称为 Major GC 或者Full GC 。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代</font>



## <font face=幼圆 color=white>五、方法区</font>

### <font face=幼圆 color=white>5.1、[方法区的理解](https://docs.oracle.com/javase/specs/jvms/se8/html/)</font>

#### <font face=幼圆 color=white>5.1.1、方法区在哪</font>

- <font face=幼圆 color=white>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”</font>
- <font face=幼圆 color=white>对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</font>
- <font face=幼圆 color=white>所以，方法区看作是一块独立于 Java 堆的内存空间。</font>

#### <font face=幼圆 color=white>5.1.2、方法区的基本理解</font>

1. <font face=幼圆 color=white>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</font>
2. <font face=幼圆 color=white>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</font>
3. <font face=幼圆 color=white>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的</font>
4. <font face=幼圆 color=white>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：PermGen space （JDK 7）或者java.lang.OutOfMemoryError:Metaspace（JDK 8）</font>

   - <font face=幼圆 color=white>加载大量的第三方的jar包</font>

   - <font face=幼圆 color=white>Tomcat部署的工程过多（30~50个）</font>

   - <font face=幼圆 color=white>大量动态的生成反射类</font>

5. <font face=幼圆 color=white>关闭 JVM 就会释放这个区域的内存</font>



### <font face=幼圆 color=white>5.2、设置方法区大小与OOM</font>

#### <font face=幼圆 color=white>5.2.1、jdk7及以前:</font>

- <font face=幼圆 color=white>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</font>

- <font face=幼圆 color=white>-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M,64位机器模式是82M</font>

- <font face=幼圆 color=white>当JVM加载的类信息容量超过了这个值,会报异常OutOfMemoryError:PermGenspace</font>

  

#### <font face=幼圆 color=white>5.2.2、jdk8及以后:</font>

- <font face=幼圆 color=white>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定,替代上述原有的两个参数</font>
- <font face=幼圆 color=white>默认值依赖与平台。windows下,-XX:MetaspaceSize是21M,-XX:MaxMetaspaceSize的值是-1,即没有限制</font>
- <font face=幼圆 color=white>和永久代不同,如果不指定大小,默认情况下,虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出,虚拟机一样会抛出异常OutOfMemoryError:Metaspace</font>
- <font face=幼圆 color=white>-XX:MetaspaceSize: 设置初始的元空间大小。对于一个64位的服务器端JVM来说,其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线,一旦触及这个水位线,Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活),然后这个高水位线将会重置。新的高水位线的值取值取决于GC后释放了多少元空间。如果释放的空间不足,那么在不超过MaxMetaspaceSize时,适当提高该值。如果释放空间过多,则适当降低该值</font>
- <font face=幼圆 color=white>如果初始化的高水位线设置过低,上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察赵Full GC多次调用。为了避免频繁地GC,建议将-XX:MetaspaceSize设置为一个相对较高的值</font>



#### <font face=幼圆 color=white>5.2.2、如何解决这些OOM</font>

1. <font face=幼圆 color=white>要解决OOM异常或heap space的异常，一.般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer) 对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow) </font>
2. <font face=幼圆 color=white>如果是内存泄漏，可进一-步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
   Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置</font>
3. <font face=幼圆 color=white>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms) ，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</font>



### <font face=幼圆 color=white>5.3、方法区内部结构</font>

![方法区结构](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\方法区结构.png)

#### <font face=幼圆 color=white>5.3.1、方法区结构</font>

​		<font face=幼圆 color=white>《深入理解Java[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)》书中对`方法区（Method Area）存储内容`描述如下：它用于存储已被虚拟机 **加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。</font>

![常量池存储什么](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\常量池存储什么.png)

##### <font face=幼圆 color=white>5.3.1.1、**类型信息**</font>

​		<font face=幼圆 color=white>对每个加载的类型`（类class、接口interface、枚举enum、注解annotation）`，[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)必须在方法区中存储以下类型信息：</font>

1. <font face=幼圆 color=white>这个类型的`全限定类名`</font>
2. <font face=幼圆 color=white>这个类型的`直接父类的全限定类名`（对于interface或是java.lang.Object，都没有父类）</font>
3. <font face=幼圆 color=white>这个类型的`修饰符（public，abstract，final的某个子集）`</font>
4. <font face=幼圆 color=white>这个类型的`直接接口的一个有序列表</font>`

##### <font face=幼圆 color=white>5.3.1.2、**域 / 字段 / 属性（Field）信息**</font>

1. <font face=幼圆 color=white>JVM必须在方法区中保存类型的所有属性的相关信息以及属性的声明顺序</font></font>
2. <font face=幼圆 color=white>域/属性的相关信息包括：</font>
   - <font face=幼圆 color=white>`属性名称`</font>
   - <font face=幼圆 color=white>`属性类型</font>`
   - <font face=幼圆 color=white>`属性饰符（public，private，protected，static，final，volatile，transient的某个子集）`</font>

##### <font face=幼圆 color=white>5.3.1.3、**方法信息**</font>

​	<font face=幼圆 color=white>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</font>

1. <font face=幼圆 color=white>`方法名称`</font>
2. <font face=幼圆 color=white>`方法的返回类型（包括 void 返回类型），void 在 Java 中对应的类为 void.class`</font>
3. <font face=幼圆 color=white>`方法参数的数量和类型（按顺序）`</font>
4. `<font face=幼圆 color=white>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</font>
5. <font face=幼圆 color=white>`方法的字节码`（bytecodes）、`操作数栈`、`局部变量表及大小`（abstract和native方法除外）</font>
6. <font face=幼圆 color=white>`异常表`（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</font>

##### <font face=幼圆 color=white>5.3.1.4、**示例**</font>

```java
 javap -v  -p MethodInnerStructest.class > text.txt
```

##### <font face=幼圆 color=white>5.3.1.4、**域信息特殊情况**</font>

1. <font face=幼圆 color=white>全局常量就是使用 static final 进行修饰</font>
2. <font face=幼圆 color=white>被声明为final的类变量的处理方法则不同，每个`全局常量在编译的时候分配初始值, 在linking的prepare阶段显示赋值`</font>

- <font face=幼圆 color=white>反编译，查看字节码指令，可以发现 `number` 的值已经写死在字节码文件中了</font>

```java
 public static int count;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC

  public static final int number;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    ConstantValue: int 2
```

##### <font face=幼圆 color=white>5.3.1.5、**运行时常量池**</font>

1. <font face=幼圆 color=white>**`方法区`，内部包含了`运行时常量池`**</font>
2. <font face=幼圆 color=white>**`字节码文件`，内部包含了`常量池`**</font>
3. <font face=幼圆 color=white>要弄清楚方法区，需要理解清楚ClassFile，因为`加载类的信息`都在`方法区`</font>
4. <font face=幼圆 color=white>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</font>

###### <font face=幼圆 color=white>5.3.1.5.1、**常量池**</font>

1. <font face=幼圆 color=white>一个有效的`字节码文件`中除了包含**类的版本信息、字段、方法以及接口等描述符信息**外</font>
2. <font face=幼圆 color=white>还包含一项信息就是**常量池表**（**Constant Pool Table**），包括 **`各种字面量和对类型、域和方法的 符号引用`**</font>

![常量池](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\常量池.png)

###### <font face=幼圆 color=white>5.3.1.5.2、**为什么需要常量池？**</font>

1. <font face=幼圆 color=white>一个`java源文件中的类、接口，编译后产生一个字节码文件`。而Java中的字节码需要`数据支`持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到**常量池**</font>
2. <font face=幼圆 color=white>这个字节码`包含了指向常量池的引用`。在`动态链接`的时候会用到`运行时常量池`，之前有介绍</font>

###### <font face=幼圆 color=white>5.3.1.5.3、**常量池中有什么？**</font>

1. <font face=幼圆 color=white>数量值</font>
2. <font face=幼圆 color=white>字符串值</font>
3. <font face=幼圆 color=white>类引用</font>
4. <font face=幼圆 color=white>字段引用</font>
5. <font face=幼圆 color=white>方法引用</font>

<font face=幼圆 color=red>总结：常量池、可以看做是一张表，`虚拟机指令`根据这张`常量表`找到要执行的**类名、方法名、参数类型、字面量**等类型</font>

###### <font face=幼圆 color=white>5.3.1.5.4、**运行时常量池**</font>

1. <font face=幼圆 color=white>**`运行时常量池（Runtime Constant Pool）`是`方法区`的`一部分`**</font>
2. <font face=幼圆 color=white>**`常量池表（Constant Pool Table）`是`Class字节码文件`的`一部分`，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中**</font>
3. <font face=幼圆 color=white>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池</font>
4. <font face=幼圆 color=white>**JVM为每个`已加载的类型（类或接口）`都维护一个`常量池`。池中的数据项像数组项一样，是通过`索引`访问的**</font>
5. <font face=幼圆 color=white>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。**此时不再是常量池中的符号地址了，这里换为真实地址**</font>
6. <font face=幼圆 color=white>运行时常量池，相对于Class文件常量池的另一重要特征是：**具备动态性。*</font>
7. <font face=幼圆 color=white>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些</font>
8. <font face=幼圆 color=white>当创建类或接口的运行时常量池时，如果`构造运行时常量池所需的内存空间超过了方法区所能提供的最大值`，则JVM会抛`OutofMemoryError异常`</font>

### <font face=幼圆 color=red>5.4、方法区演进细节 </font>

#### <font face=幼圆 color=white>5.4.1、永久代演进过程 </font>

1. <font face=幼圆 color=white>首先明确：`只有Hotspot才有永久代</font>
2. <font face=幼圆 color=white>**BEA JRockit、IBMJ9等来说，是不存在永久代的概念**的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</font>
3. <font face=幼圆 color=white>Hotspot中方法区的变化：</font>

| JDK 版本     | 演变细节                                                     |
| ------------ | ------------------------------------------------------------ |
| JDK1.6及以前 | **有永久代**（permanent generation），`静态变量存储在永久代上` |
| JDK1.7       | **有永久代**，但已经逐步 “去永久代”，**`字符串常量池，静态变量移除，保存在堆中`** |
| JDK1.8       | **无永久代**，`类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中`。 |

****

#### <font face=幼圆 color=white>5.4.2、JDK6 </font>

- <font face=幼圆 color=white>`方法区由永久代实现，使用 JVM 虚拟机内存`</font>
- <font face=幼圆 color=white>静态变量在方法区</font>
- <font face=幼圆 color=white>此时`字符串常量池(String Table)`在`方法区`的`运行时常量池`</font>

![JDK6](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\JDK6.png)



#### <font face=幼圆 color=white>5.4.3、JDK7 </font>

- <font face=幼圆 color=white>`方法区由永久代实现，使用 JVM 虚拟机内存`</font>
- <font face=幼圆 color=white>`静态变量`和`字符串常量池`放到了`堆`中</font>

![JDK7](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\JDK7.png)



#### <font face=幼圆 color=white>5.4.4、JDK8 </font>

- <font face=幼圆 color=white>`方法区由元空间实现，使用物理机本地内存`<font>

![JDK7](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\JDK8.png)



#### <font face=幼圆 color=white>5.4.5、元空间出现原因 </font>

​		<font face=幼圆 color=white>**由于`类的元数据分配在本地内存`中，`元空间的最大可分配空间就是系统可用内存空间`，这项改动是很有必要的，原因有：**</font>

1. <font face=幼圆 color=white>因为永久代设置空间大小是很难确定的</font>
   - <font face=幼圆 color=white>在某些场景下，`如果动态加载类过多`，容易产生**Perm区(永久代)的OOM**。比如某个实际Web工程中，因为功能点比较多，在运行过程中，`要不断动态加载很多类，经常出现致命错误`</font>`Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space`
   - <font face=幼圆 color=white>而元空间和永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。
     因此，**默认情况下，元空间的大小仅受本地内存限制**</font>
2. <font face=幼圆 color=white>对永久代进行调优是很困难的</font>
   - <font face=幼圆 color=white>方法区的垃圾收集主要回收两部分内容：`常量池中废弃的常量和不再用的类型`，方法区的调优主要是为了`降低Full GC`</font>
   - <font face=幼圆 color=white>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）</font>
   - <font face=幼圆 color=white>**一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</font>



#### <font face=幼圆 color=white>5.4.6、字符串常量池 (JDK7放到了堆中, 因为永久代/元空间GC概率低) </font>

1. <font face=幼圆 color=white>**`JDK7`中将`StringTable`放到了`堆空间`中**。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发</font>
2. <font face=幼圆 color=white>这就**导致StringTable回收效率不高**，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。**放到堆里，能及时回收内存**</font>

### <font face=幼圆 color=white>5.5、方法区的垃圾回收 </font>

#### <font face=幼圆 color=white>5.5.1、**方法区垃圾收集** </font>

1. <font face=幼圆 color=white>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然</font>
2. <font face=幼圆 color=white>《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）</font>
3. <font face=幼圆 color=white>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</font>

- <font face=幼圆 color=white>**方法区的垃圾收集主要回收两部分内容： **`常量池中废弃的常量和不再使用的类型。`</font>

#### <font face=幼圆 color=white>5.5.2、**方法区垃圾收集** </font>

1. <font face=幼圆 color=white>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用</font>
   - <font face=幼圆 color=white>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等</font>
   - <font face=幼圆 color=white>而符号引用则属于编译原理方面的概念，包括下面三类常量：</font>
     - <font face=幼圆 color=white>类和接口的全限定名</font>
     - <font face=幼圆 color=white>字段的名称和描述符</font>
     - <font face=幼圆 color=white>方法的名称和描述符</font>
2. <font face=幼圆 color=white>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</font>
3. <font face=幼圆 color=white>`回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）`</font>

#### <font face=幼圆 color=white>5.5.3、**方法区类型(Class)的回收** </font>

<font face=幼圆 color=white>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</font>

1. <font face=幼圆 color=white>`该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。`</font>
2. <font face=幼圆 color=white>`加载该类的类加载器已经被回收`，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通**常是很难达成**的</font>
3. <font face=幼圆 color=white>**该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。*</font>

- <font face=幼圆 color=white>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class` 以及 `-XX：+TraceClass-Loading`、`-XX：+TraceClassUnLoading`查看类加载和卸载信息</font>
- <font face=幼圆 color=white>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</font>

### <font face=幼圆 color=white>5.6、运行时数据区总结 </font>

- <font face=幼圆 color=white>`线程私有结构：程序计数器、虚拟机栈、本地方法栈`</font>
- <font face=幼圆 color=white>每个`虚拟机栈`由由具体的`栈帧`组成，在栈帧的`动态链接`中，`保存对方法的引用`</font>
- <font face=幼圆 color=white>方法区在 `JDK7 之前`，**使用永久代实现**，在 `JDK8 之后`，**使用元空间实现**</font>
- <font face=幼圆 color=white>`Minor GC 针对于新生区`，`Major GC 针对于老年区`，`Full GC 针对于整个堆空间和方法区`</font>

![运行时数据区总结](D:\project\springboot_003\src\main\resources\book\jvm\上篇：内存与垃圾回收篇\image\运行时数据区总结.png)
