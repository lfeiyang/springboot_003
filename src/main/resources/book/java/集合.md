# <font face=幼圆 color=white>集合</font>

## <font face=幼圆 color=white>一、List接口方法</font>

### <font face=幼圆 color=white>1.1、ArrayList底层结构和源码分析</font>

#### <font face=幼圆 color=white>1.1.1、基本了解</font>

1. <font face=幼圆 color=white>ArrayList可以加入null，并且多个</font>
2. <font face=幼圆 color=white>ArrayList是由数组来实现的</font>
3. <font face=幼圆 color=white>ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用ArrrayList</font>

#### <font face=幼圆 color=white>1.1.2、底层操作机制</font>

- <font face=幼圆 color=white>ArrayList中维护了一个Object类型的elementData数组</font>

  ```java
  // transient 标识瞬间，短暂的，表示该属性不会被序列化
  transient Object[] elementData; 
  ```

- <font face=幼圆 color=white>当创建ArrayList对象时，如果使用的是无参构造器，则初始的elementData容量是0。第一次添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为原容量的1.5倍</font>

- <font face=幼圆 color=white>如果使用指定大小的构造器，则初始elementData容量为指定大小。如果需要扩容，则扩容elementData为1.5倍</font>

![idea展示空元素](D:\project\springboot_003\src\main\resources\book\java\image\idea展示空元素.png)



### <font face=幼圆 color=white>1.2、Vector底层结构和源码分析</font>

1. <font face=幼圆 color=white>Vector类的定义说明</font>
2. <font face=幼圆 color=white>Vector底层也是一个对象数组，protected Object[] elementData</font>
3. <font face=幼圆 color=white>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</font>
4. <font face=幼圆 color=white>在开发中，需要线程安全时，考虑使用Vector</font>

![vector](D:\project\springboot_003\src\main\resources\book\java\image\vector.png)



### <font face=幼圆 color=white>1.3、LinkedList底层结构和源码分析</font>

1. <font face=幼圆 color=white>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作</font>
2. <font face=幼圆 color=white>可以添加任意元素(元素可以重复)，包括null</font>
3. <font face=幼圆 color=white>线程不安全，没有实现同步</font>

![linkedList02](D:\project\springboot_003\src\main\resources\book\java\image\linkedList01.png)

![linkedList02](D:\project\springboot_003\src\main\resources\book\java\image\linkedList02.png)



### <font face=幼圆 color=white>1.4、总结</font>

![list总结](D:\project\springboot_003\src\main\resources\book\java\image\list总结.png)



## <font face=幼圆 color=white>二、Set接口方法</font>

1. <font face=幼圆 color=white>无序(添加和取出的顺序不一致)，没有索引</font>
2. <font face=幼圆 color=white>不允许重复元素，所以最多包含一个null</font>
3. <font face=幼圆 color=white>和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样</font>
4. <font face=幼圆 color=white>遍历方式</font>

   - <font face=幼圆 color=white>可以使用迭代器</font>

   -  <font face=幼圆 color=white>增强for</font>

   -  <font face=幼圆 color=white><font face=幼圆 color=yellow>***不能使用***</font>索引的方式来获取</font>



### <font face=幼圆 color=white>2.1、HashSet</font>

1. <font face=幼圆 color=white>HashSet实现了Set接口</font>
2. <font face=幼圆 color=white>HashSet实际上是HashMap</font>
3. <font face=幼圆 color=white>可以存放null值，但是只能有一个null</font>
4. <font face=幼圆 color=white>HashSet不保证元素是有序的，取决于hash后，在确定索引的结果。（即不保证存放元素的顺序和取出的顺序一致）</font>
5. <font face=幼圆 color=white>不能有重复元素/对象</font>



### <font face=幼圆 color=white>2.2、HashMap底层机制说明</font>

​		<font face=幼圆 color=white>**分析HashSet底层是HashMap, HashMap底层是(数组+链表+红黑树)**</font>



### <font face=幼圆 color=white>2.3、分析HashSet的添加元素底层是如何实现 (hash() +equals())</font>

1. <font face=幼圆 color=white>HashSet底层是HashMap</font>
2. <font face=幼圆 color=white>添加一个元素时，先得到hash值 会转成->索引值</font>
3. <font face=幼圆 color=white>找到存储数据表table ,看这个索引位置是否已经存放的有元素</font>
4. <font face=幼圆 color=white>如果没有，直接加入</font>
5. <font face=幼圆 color=white>如果有,调用equals比较，如果相同，就放弃添加，如果不相同，则 添加到最后</font>
6. <font face=幼圆 color=white>在Java8中，如果一条链表的元素个数到达TREEIFY THRESHOLD(默认是8), 并且table的大小>=MIN_TREEIFY_CAPACITY(默认64), 就会进行树化(红黑树)</font>
